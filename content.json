{"pages":[],"posts":[{"title":"","text":"test 测试文档 Hello World","link":"/2022/05/10/hello-world/"},{"title":"Docker学习","text":"Docker命令容器生成#Docker run1root@dcoker-test:~# docker --name test1 run -i -t ubuntu /bin/bash 首先告诉Docker执行docker run命令，并指定了-i -t两个命令参数 -i ：保证容器中STDIN交互式shell是开启的，虽然没有附着上去，持久的标准输入是交互式shell的重点 -t：告诉Docker为创建的容器分配一个tty伪终端，这样新创建的容器才能提供一个交互式的shell –name 给容器命名 ubuntu：告诉我们需要创建Ubuntu的镜像，具体下方有内容 /bin/bash：运行/bin/bash命令创建一个bash shell 镜像 创建完毕会直接在容器中执行/bin/bash命令 -d：docker会将此容器放到后台运行。 -c：docker启动容器后会运行的命令。 #Docker createdocker create 容器操作#Docker attach（容器附着）#docker attach XXX（容器名、ID） 1root@dcoker-test:~# docker attach test1 #docker stats#docker stats XXX1 XXX2 用来显示一个或多个容器的统计信息 1234root@dcoker-test:~# docker stats test2 webCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS76a7cd4c4547 test2 0.22% 2.898MiB / 7.744GiB 0.04% 4.64kB / 0B 172kB / 0B 2ae86955aaead web 0.00% 8.191MiB / 7.744GiB 0.10% 2.66MB / 2.05MB 9.42MB / 0B 5 #docker exec#docker exec 容器内运行的进程有两种类型，后台任务和交互式任务。 1root@dcoker-test:~# docker exec -d test2 touch /etc/new_test.txt 以上命令在test2的容器中创建了net_test.txt这个文件。 12root@dcoker-test:~# docker exec -t -i test2 /bin/bashroot@76a7cd4c4547:/# 以上命令类似附着容器，比较推荐这条命令。（exit退出容器时并不会关闭容器） 容器管理#Docker info（Docker状态）12345678root@dcoker-test:~# docker infoClient: Context: default Debug Mode: false Plugins: app: Docker App (Docker Inc., v0.9.1-beta3) buildx: Build with BuildKit (Docker Inc., v0.5.1-docker) scan: Docker Scan (Docker Inc., v0.8.0) #Docker ps（容器状态）12345root@dcoker-test:~# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb2320f92d4a2 ubuntu &quot;/bin/bash&quot; 18 minutes ago Exited (127) 6 seconds ago recursing_lehmannae86955aaead njxuwu/static_web &quot;nginx -g 'daemon of…&quot; 3 months ago Up 3 months 0.0.0.0:49154-&gt;80/tcp, :::49154-&gt;80/tcp web -a 默认情况下执行docker ps 时只能看到正在运行的容器，如果指定-a的话，就会列出所有容器，包括正在运行和已经停止的。 -l：列出最后一个运行的容器，无论他什么状态 –format：更加细致控制显示哪些信息，以及如何显示这些信息。 列出镜像: docker images #Docker start等（容器状态）开启容器 docker start XXX（容器名、ID） 12root@dcoker-test:~# docker start test1test1 停止守护容器 docker stop XXX（容器命名、ID） 12root@dcoker-test:~# docker stop test1test1 重启容器 #docker restart XXX 创建容器但是并不运行 #docker create 自动重启容器 docker run可以通过–restart标志来让容器检查退出代码。当退出代码符合时。自动重启容器。 1root@dcoker-test:~# docker run --restart=always --name test3 -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1;done&quot; –restart有以下设置： always：无论退出代码是什么，docker都会重启该容器 on-failure：只有当退出代码为0是才会重启，且该参数支持设置重启字数。例如--restart=on-failure:5 删除容器 docker rm ID 12root@dcoker-test:~# docker rm 1f606093de64 1f606093de64 删除容器前必须先停止容器可以使用docker stop 或者docker kill命令来停止容器 1docker rm ·docker ps -a -q· 删除所有容器 -a：列出所有容器 -q：只返回容器的ID而不返回容器的其他信息 #Docker logs（日志）#docker logs XXX 123456root@dcoker-test:~# docker logs test2hello worldhello worldhello worldhello worldhello world 通过上条命令。容器自动循环打印hello world，可以通过命令获取守护式容器的日志。 -f：一直监控该容器的日志，不会退出。（Ctrl+C）退出跟踪 –tail 数字：只查看日志的某一片段，例如--tall 10：获取日志的最后10行内容“如果为 0的话就是获取最新的日志内容。” -t：为每条日志加上时间戳。使用实例：docker logs -ft #docker top（查看容器进程）#docker top XXX 123root@dcoker-test:~# docker top test2UID PID PPID C STIME TTY TIME CMDroot 52448 85690 0 15:37 ? 00:00:00 sleep 1 #docker stats（容器资源占用）#docker stats XXX1 XXX2 用来显示一个或多个容器的统计信息 1234root@dcoker-test:~# docker stats test2 webCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS76a7cd4c4547 test2 0.22% 2.898MiB / 7.744GiB 0.04% 4.64kB / 0B 172kB / 0B 2ae86955aaead web 0.00% 8.191MiB / 7.744GiB 0.10% 2.66MB / 2.05MB 9.42MB / 0B 5 #docker inspect（容器信息）#docker inspect 通过docker inspect可以让容器显示更多的信息 1234567891011121314151617181920212223root@dcoker-test:~# docker inspect test2[ { &quot;Id&quot;: &quot;76a7cd4c4547d73ae8e64bd280302daafd17b0277a661ecba85e78480a2fae70&quot;, &quot;Created&quot;: &quot;2022-05-10T05:25:05.647592221Z&quot;, &quot;Path&quot;: &quot;/bin/sh&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true; do echo hello world; sleep 1;done&quot; ], &quot;State&quot;: { &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 85690, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2022-05-10T05:25:06.538612861Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; }, 可以通过具体参数来详细配置 -f或–format：选定查看结果。例如： 1docker inspect --format='{{ .State.Running }}' test2 查看test2的运行状态 1docker inspect --format='{{ .NetworkSettings.IPAddress }}' test2 查看容器IP地址 该命令支持查看多个容器状态 1root@dcoker-test:~# docker inspect --format='{{ .NetworkSettings.IPAddress }}' \\ test2 test3 dockerDocker介绍容器介绍Docker属于容器,与管理程序虚拟化(hypervisor virtualization/HV)**不同.HV是通过中间层将多台独立的虚拟机运行在物理硬件上.容器是直接运行在操作系统内核之上的用户空间(**操作系统级虚拟化)容器技术可以让多个独立的用户空间运行在同一台宿主机上. 由于主体操作系统不同,容器只能运行与底层宿主主机相同或相似的操作系统,例如linux只能运行linux容器 容器被广泛用于多租户的服务部署.权限隔离监牢(chroot jail)创建隔离环境来运行服务,攻击者入侵成功,权限也不足以进行下一步操作. 最新容器技术引入了OpenVZ、Solaris Zones以及linux容器（lxc）。对于Docker来说，得益于现代linux内核特性，如控件组（control group）、命名空间（name space）技术，容器和宿主机隔离更加彻底，容器拥有独立的网络和存储栈，还拥有自己的资源管理能力。 容器和传统的虚拟化以及半虚拟化（paravirtualization）相比，容器不需要模拟层（emulation layer）和管理层（hupervisorlayer），而是使用操作系统的系统调用接口。降低了容器开销。 Docker简介基于Apache2.0开源授权协议发行开源协议2.0是对商业应用友好的许可，在需要的时候可以修改源代码以商业化发布销售 Docke鼓励使用面向服务的构架和微服务构架。推荐单个容器只允许一个应用程序或进程，形成一个分布式的应用程序模型。 Docker核心组件： Docker客户端和服务器（docker引擎）； Docker镜像 Regisrty Docker容器 Docker是客户端/服务器(C/S)架构，Docker客户端只需要向服务器或守护进程发送请求，服务器或守护进程返回所有结果。Docker守护进程也称为Docker引擎。Docker提供了一个命令行工具docker以及一整套RESTful API来与守护进程交互。用户可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地Docker客户端连接运行其他主机上的Docker守护进程。 镜像是Docker的基石，用户基于镜像来搭建容器，镜像基于联合（Union）文件系统的一种层式结构，有一系列指令一步一步构建 Docker的技术组件： 原生Linux容器格式，Docker中称之为（libcontainer） Linux内核的命名控件（namespace）用于隔离文件系统，进程和网络 文件隔离系统每个容器都有自己的root文件系统 进程隔离 网络隔离 资源隔离和分组使用cgroups（control grouplinux内核特性之一）将CPU、内存独立分配给容器 写时复制文件系统都是通过写时复制创建，意味文件系统分层且快速占用率小 日志容器产生的STDOUT、STDERR和STDIN这些IO流都会被收集并记入日志 交互式shell用户创建一个伪tty终端，将其连接到STDIN Docker基础操作查看Docker基本信息#docker info 12345678root@dcoker-test:~# docker infoClient: Context: default Debug Mode: false Plugins: app: Docker App (Docker Inc., v0.9.1-beta3) buildx: Build with BuildKit (Docker Inc., v0.5.1-docker) scan: Docker Scan (Docker Inc., v0.8.0) 创建容器#docker run 1root@dcoker-test:~# docker run -i -t ubuntu /bin/bash 首先告诉Docker执行docker run命令，并指定了-i -t两个命令参数 -i ：保证容器中STDIN交互式shell是开启的，虽然没有附着上去，持久的标准输入是交互式shell的重点 -t：告诉Docker为创建的容器分配一个tty伪终端，这样新创建的容器才能提供一个交互式的shell ubuntu：告诉我们需要创建Ubuntu的镜像，具体下方有内容 /bin/bash：运行/bin/bash命令创建一个bash shell 镜像 创建完毕会直接在容器中执行/bin/bash命令 如果要创建一个我们能与之交互的容器，而不是一个运行后台服务的容器，这两个参数是最基本的参数。 可以使用docker help run查看所有参数 Docker创建步骤以上实例镜像是ubuntu镜像，是一个常备镜像，也可以称之为“基础”（base）镜像，由Docker公司提供，也可以基于Ubuntu镜像为基础，构造自己的镜像。 容器创建步骤： 检查本地是否存在ubuntu镜像。 如果没有镜像会连接官网维护的Docker Hub Registry，查看Docker Hub中是否存在该镜像。 Docker一旦找到该镜像就会下载该镜像保存到本地宿主机中 随后利用这个镜像创建一个新的容器，该容器拥有自己的网络、IP地址，以及一个用来和宿主机通信的桥接网络接口 最后在容器中运行创建容器命令行中附带的命令 当我们输入exit退出容器是，容器就停止运行了。只有在指定的命令处于运行状态时，容器才会相应 处于运行状态，一旦退出容器，命令就结束了，这时候容器也会随之停止运行。 但是容器仍然存在。 查看容器列表#docker ps -a 12345root@dcoker-test:~# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb2320f92d4a2 ubuntu &quot;/bin/bash&quot; 18 minutes ago Exited (127) 6 seconds ago recursing_lehmannae86955aaead njxuwu/static_web &quot;nginx -g 'daemon of…&quot; 3 months ago Up 3 months 0.0.0.0:49154-&gt;80/tcp, :::49154-&gt;80/tcp web -a 默认情况下执行docker ps 时只能看到正在运行的容器，如果指定-a的话，就会列出所有容器，包括正在运行和已经停止的。 -l：列出最后一个运行的容器，无论他什么状态 –format：更加细致控制显示哪些信息，以及如何显示这些信息。 以上输入结果中可以看到容器的很多信息： CONTAINER IS IMAGE COMMAND CREATED STATUS PORTS NAMES 容器ID（短UUID() 创建容器的镜像名 容器最后执行的命令 创建容器时间 容器状态 端口映射 容器名 有三种方法可以指定容器 短UUID 长UUID 容器名 容器命名#docker run –name XXX 1root@dcoker-test:~# docker run --name test1 -i -t ubuntu /bin/bash 合法容器名只支持: 小写字母 大写字母 数字 下划线 圆点 横线 启动已经停止的容器docker start XXX（容器名、ID） 12root@dcoker-test:~# docker start test1test1 #docker restart XXX 重启容器 #docker create 创建容器但是并不运行 附着到容器上#docker attach XXX（容器名、ID） 1root@dcoker-test:~# docker attach test1 创建守护式容器以上属于交互式运行的容器（interactive container），也可以创建长期运行的容器，也就是守护式容器（deamonized container） 守护式容器没有交互式会话，非常时候用来运行应用程序和服务。 #docker run 12root@dcoker-test:~# docker run --name test2 -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1;done&quot;76a7cd4c4547d73ae8e64bd280302daafd17b0277a661ecba85e78480a2fae7 -d：docker会将此容器放到后台运行。 -c：docker启动容器后会运行的命令。 容器日志查看#docker logs XXX 123456root@dcoker-test:~# docker logs test2hello worldhello worldhello worldhello worldhello world 通过上条命令。容器自动循环打印hello world，可以通过命令获取守护式容器的日志。 -f：一直监控该容器的日志，不会退出。（Ctrl+C）退出跟踪 –tail 数字：只查看日志的某一片段，例如--tall 10：获取日志的最后10行内容“如果为 0的话就是获取最新的日志内容。” -t：为每条日志加上时间戳。使用实例：docker logs -ft Docker日志驱动从Docker1.6版本之后，可以控制Docker守护进程和容器的日志驱动，通过–log-driver选项来实现，该选项在执行docker run时使用 该选项有多个选择，默认为json-file。也是docker logs的基础。 其他还包括： syslog：该选项会导致docker logs被禁用，所有日志都会被定向到syslog。命令实例：docker run --log-driver=“syslog” none：该选项会禁用所有容器日志。docker logs也会被禁用。 如果在docker toolbox中启动docker，应该在虚拟机中启动syslog守护进程。可以先通过docker-machine ssh连接到虚拟机，在其中运行syslogd命令来启动syslog守护进程 注：在1.8以上版本中，添加了对Graylog GELF协议、Fluentd以及日志轮转驱动的支持 查看容器内进程#docker top XXX 123root@dcoker-test:~# docker top test2UID PID PPID C STIME TTY TIME CMDroot 52448 85690 0 15:37 ? 00:00:00 sleep 1 Docker容器统计信息#docker stats XXX1 XXX2 用来显示一个或多个容器的统计信息 1234root@dcoker-test:~# docker stats test2 webCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS76a7cd4c4547 test2 0.22% 2.898MiB / 7.744GiB 0.04% 4.64kB / 0B 172kB / 0B 2ae86955aaead web 0.00% 8.191MiB / 7.744GiB 0.10% 2.66MB / 2.05MB 9.42MB / 0B 5 在容器内部运行进程#docker exec 容器内运行的进程有两种类型，后台任务和交互式任务。 1root@dcoker-test:~# docker exec -d test2 touch /etc/new_test.txt 以上命令在test2的容器中创建了net_test.txt这个文件。 12root@dcoker-test:~# docker exec -t -i test2 /bin/bashroot@76a7cd4c4547:/# 以上命令类似附着容器，比较推荐这条命令。（exit退出容器时并不会关闭容器） 停止守护容器docker stop XXX（容器命名、ID） 12root@dcoker-test:~# docker stop test1test1 停止守护容器 自动重启容器docker run可以通过–restart标志来让容器检查退出代码。当退出代码符合时。自动重启容器。 1root@dcoker-test:~# docker run --restart=always --name test3 -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1;done&quot; –restart有以下设置： always：无论退出代码是什么，docker都会重启该容器 on-failure：只有当退出代码为0是才会重启，且该参数支持设置重启字数。例如--restart=on-failure:5 深入容器#docker inspect 通过docker inspect可以让容器显示更多的信息 1234567891011121314151617181920212223root@dcoker-test:~# docker inspect test2[ { &quot;Id&quot;: &quot;76a7cd4c4547d73ae8e64bd280302daafd17b0277a661ecba85e78480a2fae70&quot;, &quot;Created&quot;: &quot;2022-05-10T05:25:05.647592221Z&quot;, &quot;Path&quot;: &quot;/bin/sh&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true; do echo hello world; sleep 1;done&quot; ], &quot;State&quot;: { &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 85690, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2022-05-10T05:25:06.538612861Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; }, 可以通过具体参数来详细配置 -f或–format：选定查看结果。例如： 1docker inspect --format='{{ .State.Running }}' test2 查看test2的运行状态 1docker inspect --format='{{ .NetworkSettings.IPAddress }}' test2 查看容器IP地址 该命令支持查看多个容器状态 1root@dcoker-test:~# docker inspect --format='{{ .NetworkSettings.IPAddress }}' \\ test2 test3 删除容器docker rm ID 12root@dcoker-test:~# docker rm 1f606093de64 1f606093de64 删除容器前必须先停止容器可以使用docker stop 或者docker kill命令来停止容器 1docker rm ·docker ps -a -q· 删除所有容器 -a：列出所有容器 -q：只返回容器的ID而不返回容器的其他信息 Docker镜像和仓库列出镜像: #docker image 12345root@dcoker-test:~# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnjxuwu/static_web latest 5be560498a3c 4 months ago 162MBnjxuwu/apache2 webserver 1f43a57530aa 4 months ago 218MBnjxuwu/apache2 latest cae38229b7bb 4 months ago 218MB 本地镜像都保存在/var/lib/docker目录下,每个镜像都保存在Docker所采用的存储驱动目录下面,如aufs或者devicemapper.也可以在/var/lib/docker/containers目录下看到所有容器.","link":"/2022/05/11/docker/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"Docker","slug":"Docker","link":"/categories/Docker/"}]}